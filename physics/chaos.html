<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaos Engine | RK4 Physics</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Inter:wght@400;600&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg: #0f1115;
            --surface: #161b22;
            --border: #30363d;
            --accent: #58a6ff;
            --ghost: #ff7b72; /* Red for the chaos shadow */
            --text-main: #c9d1d9;
            --text-muted: #8b949e;
            
            --font-ui: 'Inter', sans-serif;
            --font-mono: 'Fira Code', monospace;
        }

        * { box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: var(--font-ui);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* HEADER */
        header {
            height: 50px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            background: var(--surface);
            justify-content: space-between;
            flex-shrink: 0;
        }
        h1 { font-size: 1rem; font-weight: 600; margin: 0; }
        .badge { 
            font-family: var(--font-mono); font-size: 0.7rem; 
            background: #238636; color: white; padding: 2px 8px; border-radius: 4px; 
        }

        /* LAYOUT */
        .workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* SIDEBAR */
        .sidebar {
            width: 280px;
            background: #0d1117;
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 24px;
            flex-shrink: 0;
            overflow-y: auto;
        }

        .control-group { display: flex; flex-direction: column; gap: 8px; }
        
        .label-row {
            display: flex; justify-content: space-between;
            font-size: 0.75rem; color: var(--text-muted); font-weight: 600;
            text-transform: uppercase;
        }
        .val-display { font-family: var(--font-mono); color: var(--accent); }

        /* SLIDERS */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: var(--text-main); cursor: pointer; margin-top: -6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: var(--border); border-radius: 2px;
        }
        input[type=range]:focus::-webkit-slider-thumb { background: var(--accent); }

        /* BUTTONS & TOGGLES */
        .btn-action {
            background: var(--surface); border: 1px solid var(--border);
            color: var(--text-main); padding: 12px; border-radius: 4px;
            cursor: pointer; font-family: var(--font-mono); font-size: 0.8rem;
            transition: 0.2s; text-transform: uppercase;
        }
        .btn-action:hover { border-color: var(--accent); background: var(--border); }

        .checkbox-row {
            display: flex; align-items: center; justify-content: space-between;
            font-size: 0.85rem; cursor: pointer;
        }
        input[type="checkbox"] { accent-color: var(--accent); width: 16px; height: 16px; }

        /* MAIN SIMULATION */
        .sim-container {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #1b2129 0%, #0f1115 100%);
        }
        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

        .overlay-info {
            position: absolute; bottom: 20px; left: 20px;
            font-family: var(--font-mono); font-size: 0.75rem; color: var(--text-muted);
            pointer-events: none; opacity: 0.7;
            display: flex; flex-direction: column; gap: 5px;
        }
        .legend-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; }

    </style>
</head>
<body>

    <header>
        <h1>Double Pendulum</h1>
        <span class="badge">RK4 INTEGRATION</span>
    </header>

    <div class="workspace">
        <aside class="sidebar">
            
            <div class="control-group">
                <div class="label-row">
                    <span>Mass 1</span>
                    <span id="dispM1" class="val-display">10</span>
                </div>
                <input type="range" id="inM1" min="1" max="40" value="10">
            </div>

            <div class="control-group">
                <div class="label-row">
                    <span>Mass 2</span>
                    <span id="dispM2" class="val-display">10</span>
                </div>
                <input type="range" id="inM2" min="1" max="40" value="10">
            </div>

            <div class="control-group">
                <div class="label-row">
                    <span>Gravity</span>
                    <span id="dispG" class="val-display">9.8</span>
                </div>
                <input type="range" id="inG" min="1" max="20" step="0.1" value="9.8">
            </div>

            <div style="border-top: 1px solid var(--border); margin: 10px 0;"></div>

            <label class="checkbox-row">
                <span>Compare Chaos (Show Ghost)</span>
                <input type="checkbox" id="checkGhost" checked>
            </label>
            
            <label class="checkbox-row">
                <span>Show Trajectory</span>
                <input type="checkbox" id="checkTrace" checked>
            </label>

            <button class="btn-action" onclick="resetSim()">Randomize State</button>
            <button class="btn-action" onclick="togglePause()">Pause / Resume</button>

        </aside>

        <main class="sim-container">
            <canvas id="simCanvas"></canvas>
            <div class="overlay-info">
                <div><span class="legend-dot" style="background:var(--accent)"></span>System A</div>
                <div><span class="legend-dot" style="background:var(--ghost)"></span>System B (Î” 0.001 rad)</div>
                <div style="margin-top:5px">Drag System A to interact</div>
            </div>
        </main>
    </div>

    <script>
        // --- PHYSICS CONFIG ---
        const L1 = 150; // Lengths (pixels)
        const L2 = 150;
        let M1 = 10;    // Masses
        let M2 = 10;
        let G = 9.81;
        
        // System State [theta1, theta2, omega1, omega2]
        // We run two simulations simultaneously to show divergence
        let s1 = [Math.PI/2, Math.PI/2, 0, 0]; 
        let s2 = [Math.PI/2 + 0.001, Math.PI/2, 0, 0]; // Perturbed state

        let trace1 = [];
        let trace2 = [];
        const MAX_TRACE = 250;

        let paused = false;
        let dragging = false;
        let dragTarget = 0; // 1 or 2 (which bob)

        // --- DOM REFS ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const uiM1 = document.getElementById('inM1');
        const uiM2 = document.getElementById('inM2');
        const uiG = document.getElementById('inG');

        // --- EQUATIONS OF MOTION ---
        // Returns derivatives [dTheta1, dTheta2, dOmega1, dOmega2]
        function derivatives(state) {
            const t1 = state[0];
            const t2 = state[1];
            const w1 = state[2];
            const w2 = state[3];
            
            // Common terms for Lagrangian calc
            const dt = t1 - t2;
            const denCommon = 2 * M1 + M2 - M2 * Math.cos(2 * t1 - 2 * t2);
            const den1 = L1 * denCommon;
            const den2 = L2 * denCommon;

            // Angular Velocity Derivatives (Omega) = Angular positions
            const dt1 = w1;
            const dt2 = w2;

            // Angular Acceleration Equations (Alpha)
            const num1 = -G * (2 * M1 + M2) * Math.sin(t1) 
                         - M2 * G * Math.sin(t1 - 2 * t2) 
                         - 2 * Math.sin(dt) * M2 * (w2 * w2 * L2 + w1 * w1 * L1 * Math.cos(dt));
            const dw1 = num1 / den1;

            const num2 = 2 * Math.sin(dt) * (w1 * w1 * L1 * (M1 + M2) + G * (M1 + M2) * Math.cos(t1) + w2 * w2 * L2 * M2 * Math.cos(dt));
            const dw2 = num2 / den2;

            return [dt1, dt2, dw1, dw2];
        }

        // --- RK4 SOLVER ---
        function rk4Step(state, dt) {
            const k1 = derivatives(state);
            
            const s2 = state.map((v, i) => v + k1[i] * dt * 0.5);
            const k2 = derivatives(s2);
            
            const s3 = state.map((v, i) => v + k2[i] * dt * 0.5);
            const k3 = derivatives(s3);
            
            const s4 = state.map((v, i) => v + k3[i] * dt);
            const k4 = derivatives(s4);

            return state.map((v, i) => v + (dt / 6) * (k1[i] + 2 * k2[i] + 2 * k3[i] + k4[i]));
        }

        // --- MAIN LOOP ---
        let cx, cy;

        function resize() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            cx = canvas.width / 2;
            cy = canvas.height / 3.5;
        }
        window.addEventListener('resize', resize);
        resize();

        function animate() {
            requestAnimationFrame(animate);

            if (!paused && !dragging) {
                // Time step (smaller = more precise)
                const dt = 0.15; 
                
                // Integrate
                s1 = rk4Step(s1, dt);
                
                // Only run ghost physics if enabled
                if(document.getElementById('checkGhost').checked) {
                    s2 = rk4Step(s2, dt);
                }

                // Damping (Friction) - essential for realism otherwise it spins forever
                s1[2] *= 0.999; s1[3] *= 0.999;
                s2[2] *= 0.999; s2[3] *= 0.999;

                // Update Traces
                updateTrace(s1, trace1);
                updateTrace(s2, trace2);
            }

            draw();
        }

        function updateTrace(state, trace) {
            if(!document.getElementById('checkTrace').checked) {
                if(trace.length) trace.length = 0;
                return;
            }
            
            // Calculate position of Bob 2
            const x1 = L1 * Math.sin(state[0]);
            const y1 = L1 * Math.cos(state[0]);
            const x2 = x1 + L2 * Math.sin(state[1]);
            const y2 = y1 + L2 * Math.cos(state[1]);
            
            trace.push({x: cx + x2, y: cy + y2});
            if (trace.length > MAX_TRACE) trace.shift();
        }

        // --- DRAWING ---
        function draw() {
            // Clear
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const showGhost = document.getElementById('checkGhost').checked;

            // Draw Ghost First (Background)
            if(showGhost) {
                drawSystem(s2, trace2, 'rgba(255, 123, 114, 0.4)', 'rgba(255, 123, 114, 0.15)', true);
            }

            // Draw Main System
            drawSystem(s1, trace1, '#58a6ff', '#58a6ff', false);
        }

        function drawSystem(state, trace, colorMain, colorTrace, isGhost) {
            const x1 = cx + L1 * Math.sin(state[0]);
            const y1 = cy + L1 * Math.cos(state[0]);
            const x2 = x1 + L2 * Math.sin(state[1]);
            const y2 = y1 + L2 * Math.cos(state[1]);

            // Trace
            if (trace.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = colorTrace;
                ctx.lineWidth = isGhost ? 1 : 2;
                ctx.moveTo(trace[0].x, trace[0].y);
                for (let i = 1; i < trace.length; i++) ctx.lineTo(trace[i].x, trace[i].y);
                ctx.stroke();
            }

            // Rods
            ctx.beginPath();
            ctx.strokeStyle = isGhost ? colorTrace : '#30363d';
            ctx.lineWidth = 2;
            ctx.moveTo(cx, cy);
            ctx.lineTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // Joints/Bobs
            ctx.fillStyle = colorMain;
            
            // Joint 1
            ctx.beginPath();
            ctx.arc(x1, y1, isGhost ? 3 : (M1/2), 0, Math.PI * 2);
            ctx.fill();

            // Joint 2
            ctx.beginPath();
            ctx.arc(x2, y2, isGhost ? 3 : (M2/2), 0, Math.PI * 2);
            ctx.fill();
        }

        // --- INPUTS & INTERACTIONS ---
        
        // Sliders
        uiM1.addEventListener('input', (e) => { M1 = +e.target.value; document.getElementById('dispM1').innerText = M1; });
        uiM2.addEventListener('input', (e) => { M2 = +e.target.value; document.getElementById('dispM2').innerText = M2; });
        uiG.addEventListener('input', (e) => { G = +e.target.value; document.getElementById('dispG').innerText = G; });

        function resetSim() {
            trace1 = []; trace2 = [];
            // Randomize but keep them close to demonstrate divergence
            const start1 = Math.PI + (Math.random() - 0.5) * 2;
            const start2 = Math.PI + (Math.random() - 0.5) * 2;
            
            s1 = [start1, start2, 0, 0];
            s2 = [start1 + 0.001, start2, 0, 0]; // The butterfly effect
        }

        function togglePause() { paused = !paused; }

        // Mouse Dragging
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            // Calculate current positions
            const x1 = cx + L1 * Math.sin(s1[0]);
            const y1 = cy + L1 * Math.cos(s1[0]);
            const x2 = x1 + L2 * Math.sin(s1[1]);
            const y2 = y1 + L2 * Math.cos(s1[1]);

            if (Math.hypot(mx - x1, my - y1) < 30) dragTarget = 1;
            else if (Math.hypot(mx - x2, my - y2) < 30) dragTarget = 2;

            if (dragTarget) {
                dragging = true;
                paused = true; // Pause physics while dragging
                // Reset velocities
                s1[2] = 0; s1[3] = 0;
                s2[2] = 0; s2[3] = 0;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            if (dragTarget === 1) {
                s1[0] = Math.atan2(mx - cx, my - cy);
                // Keep bob 2 relative angle same-ish or just drag 1
            } else if (dragTarget === 2) {
                const x1 = cx + L1 * Math.sin(s1[0]);
                const y1 = cy + L1 * Math.cos(s1[0]);
                s1[1] = Math.atan2(mx - x1, my - y1);
            }
            
            // Sync ghost to main
            s2 = [...s1]; 
            s2[0] += 0.001; // tiny offset
            
            draw();
        });

        window.addEventListener('mouseup', () => {
            if (dragging) {
                dragging = false;
                dragTarget = 0;
                paused = false;
                trace1 = []; trace2 = [];
            }
        });

        // Start
        animate();
        
    </script>
</body>
</html>